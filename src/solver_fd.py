import os, sys
import utils_apk, defs_apk


verbose = False
FD_PLAN_FILE_NAME = 'sas_plan'

"""
Activating the fast downward planner with domain_file_name and problem_file_name and output the result to destination_folder
"""
def solve(solver_path, domain_file_name, problem_file_name, destination_folder,time_limit = defs_apk.DEFAULT_TIME_LIMIT, heuristic = 'lmcut()') :#heuristic = 'ipdb()'):


    planning_failed = False
    plan_cmd = downward_command(destination_folder, domain_file_name, problem_file_name, solver_path, time_limit, '', heuristic)
    [signal, plan, plan_cost] = plan_cmd.execute_and_parse()

    if signal != 0:
        print('plan_for %s and %s == failed' % (domain_file_name, problem_file_name))
        planning_failed = True
    else:
        if ((plan_cmd.plan_cost == -1)):
            print('plan_for %s and %s == no_solution' % (domain_file_name, problem_file_name))
            planning_failed = True

    return [signal, plan, plan_cost]


"""
Activating the fast downward planner with domain_file_name and problem_file_name and output the result to destination_folder
"""
def translate(solver_path, domain_file_name, problem_file_name, destination_folder):

    translate_failed = False
    plan_cmd = downward_command(destination_folder, domain_file_name, problem_file_name, solver_path)
    signal = plan_cmd.translate()

    if signal != 0:
        print('plan_for %s and %s == failed' % (domain_file_name, problem_file_name))
        planning_failed = True
    else:
        if ((plan_cmd.plan_cost == -1)):
            print('plan_for %s and %s == no_solution' % (domain_file_name, problem_file_name))
            planning_failed = True

    return signal

"""
Get the causal graph 
"""
def get_causal_graph(solver_path, domain_file_name, problem_file_name, destination_folder, output_file_name):

    plan_cmd = downward_command(destination_folder, domain_file_name, problem_file_name, solver_path)
    plan_cmd.get_causal_graph(output_file_name)




"""
The fast downward command :
"""


class downward_command:
    """fast downward command
    website: http://www.fast-downward.org/

    requirements:
    -python 2.7
    -fast downward installed in grd_defs.downward_path

    """

    def __init__(self, destination_folder_name, domainfilename, problemfilename, solver_path, max_time=defs_apk.DEFAULT_TIME_LIMIT,
                 upper_bound='', heuristic='lmcut()', max_mem=2048, log_file_name=None):
        self.domain_file_name = os.path.abspath(domainfilename)
        self.problem_file_name = os.path.abspath(problemfilename)
        self.solver_path = os.path.abspath(solver_path)
        self.noext_problem = os.path.basename(self.problem_file_name).replace('.pddl', '')
        self.max_time = max_time
        self.max_mem = max_mem
        self.heuristic = heuristic
        self.upper_bound = upper_bound
        self.plan_cost = 0
        self.signal = 0
        self.destination_folder_name = destination_folder_name
        self.num_expanded_states = -1
        self.log_file_name = log_file_name

    def execute(self):
        """executing fast downward search command via 3 steps:
            --Translate
            --Preporocess
            --Search
           result is processed in gather_data
        """
        cmd_string_planner = '%s/fast-downward.py %s %s --search "astar(lmcut())"'%(self.solver_path, self.domain_file_name,self.problem_file_name)

        self.signal, self.time = utils_apk.run(cmd_string_planner, self.destination_folder_name ,self.max_time, self.max_mem, self.log_file_name, verbose)
        if (self.signal != 0):
            print("! ! ! signal is not 0 - it is %d" % self.signal)

    def translate(self):
        """executing fast downward search command via 3 steps:
            --Translate
            --Preporocess
            --Search
           result is processed in gather_data
        """
        cmd_string_planner = '%s/fast-downward.py --translate %s %s'%(self.solver_path, self.domain_file_name,self.problem_file_name)

        self.signal, self.time = utils_apk.run(cmd_string_planner, self.destination_folder_name ,self.max_time, self.max_mem, self.log_file_name, verbose)
        if (self.signal != 0):
            print("! ! ! signal is not 0 - it is %d" % self.signal)
        return self.signal

    def execute_and_parse(self):

        self.execute()

        plan = None
        plan_cost = -1
        if self.signal == 0:
            # process results
            [plan, plan_cost] = self.gather_data(os.path.join(self.destination_folder_name, FD_PLAN_FILE_NAME))

        return [self.signal,plan, plan_cost]

    def gather_data(self, plan_file):

        '''
        analyzing the log file generated by the fast dowanrd command:  Search_downward.log
        :return:NIL
        '''
        plan = []
        plan_cost = -1
        if os.path.exists(plan_file):
            instream = open(plan_file, 'r')
            lines = instream.readlines()
            for line in lines:
                if 'cost' in line :
                    plan_cost = line.split()[3]
                plan.append(line)


            instream.close()

        return [plan, plan_cost]

    def write_result(self, filename):

        res = csv.writer(open('%s' % filename, 'w'))

        res.writerow(
            [os.path.basename(self.domain_file_name), os.path.basename(self.problem_file_name), self.signal, self.time,
             self.plan_cost])

    def get_causal_graph(self, output_file_name):
        """executing fast downward command to generate causal graph:
                   result is processed in gather_causal_graph
                """
        cmd_string_planner = '%s/fast-downward.py %s %s --dcg > %s' % (self.solver_path, self.domain_file_name, self.problem_file_name, output_file_name)

        self.signal, self.time = utils_apk.run(cmd_string_planner, self.destination_folder_name, self.max_time,
                                           self.max_mem, self.log_file_name, verbose)
        if (self.signal != 0):
            print("! ! ! signal is not 0 - it is %d" % self.signal)




def test_perform_planning_fd():

    utils_apk.empty_or_create_log_and_gen_dir()

    solver_path = defs_apk.FD_PATH
    domain_file_name = sys.argv[1]
    problem_file_name =  sys.argv[2]
    destination_folder = defs_apk.get_gen_folder_name()
    time_limit = defs_apk.DEFAULT_TIME_LIMIT
    heuristic = 'lmcut()'  # heuristic = 'ipdb()'):
    solve(solver_path, domain_file_name, problem_file_name, destination_folder, time_limit, heuristic)

def test_translate_fd():

    utils.empty_or_create_log_and_gen_dir()

    solver_path = sys.argv[1]
    domain_file_name = sys.argv[2]
    problem_file_name =  sys.argv[3]
    destination_folder = defs_apk.get_gen_folder_name()
    translate(solver_path, domain_file_name, problem_file_name, destination_folder)


def test_get_causal_graph_1():

    utils.empty_or_create_log_and_gen_dir()

    solver_path = sys.argv[1]
    domain_file_name = sys.argv[2]
    problem_file_name =  sys.argv[3]
    destination_folder = defs_apk.get_gen_folder_name()
    get_causal_graph(solver_path, domain_file_name, problem_file_name, destination_folder)


def test_get_causal_graph():

    utils.empty_or_create_log_and_gen_dir()
    solver_path = defs_apk.FD_PATH
    domain_file_name = sys.argv[1]
    problem_file_name =  sys.argv[2]
    destination_folder = defs_apk.get_gen_folder_name()
    get_causal_graph(solver_path, domain_file_name, problem_file_name, destination_folder,'test_causal')



if __name__ == '__main__':

    test_perform_planning_fd()
    #test_translate_fd()
    #test_get_causal_graph()
